e1000e: implement MDI-X control

From: Jesse Brandeburg <jesse.brandeburg@intel.com>

some users report issues with link failing when connected
to certain switches.  This gives the user the ability to
control the MDI-X state from the driver.

Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
---

 drivers/net/e1000e/e1000.h  |    2 ++
 drivers/net/e1000e/netdev.c |    3 ++-
 drivers/net/e1000e/param.c  |   27 +++++++++++++++++++++++++++
 3 files changed, 31 insertions(+), 1 deletions(-)


diff --git a/drivers/net/e1000e/e1000.h b/drivers/net/e1000e/e1000.h
index d6ee28f..d8447b6 100644
--- a/drivers/net/e1000e/e1000.h
+++ b/drivers/net/e1000e/e1000.h
@@ -90,6 +90,8 @@ struct e1000_info;
 #define E1000_RX_BUFFER_WRITE		16 /* Must be power of 2 */
 
 #define AUTO_ALL_MODES			0
+#define FORCE_MDI			1
+#define FORCE_MDIX			2
 #define E1000_EEPROM_APME		0x0400
 
 #define E1000_MNG_VLAN_NONE		(-1)
diff --git a/drivers/net/e1000e/netdev.c b/drivers/net/e1000e/netdev.c
index c990341..be3676a 100644
--- a/drivers/net/e1000e/netdev.c
+++ b/drivers/net/e1000e/netdev.c
@@ -5379,7 +5379,8 @@ static int __devinit e1000_probe(struct pci_dev *pdev,
 
 	/* Copper options */
 	if (adapter->hw.phy.media_type == e1000_media_type_copper) {
-		adapter->hw.phy.mdix = AUTO_ALL_MODES;
+		/* already set in e1000_check_options */
+		/* adapter->hw.phy.mdix = AUTO_ALL_MODES; */
 		adapter->hw.phy.disable_polarity_correction = 0;
 		adapter->hw.phy.ms_type = e1000_ms_hw_default;
 	}
diff --git a/drivers/net/e1000e/param.c b/drivers/net/e1000e/param.c
index 2e39977..6600376 100644
--- a/drivers/net/e1000e/param.c
+++ b/drivers/net/e1000e/param.c
@@ -160,6 +160,15 @@ E1000_PARAM(WriteProtectNVM, "Write-protect NVM [WARNING: disabling this can lea
  */
 E1000_PARAM(CrcStripping, "Enable CRC Stripping, disable if your BMC needs " \
                           "the CRC");
+/*
+ * Control MDI-X crossover auto-detection
+ *
+ * Valid Range: 0, 1, 2
+ *
+ * Default Value: 0 (automatic)
+ */
+E1000_PARAM(mdix,
+    "MDI-X crossover control: 0 - auto (default), 1 - mdi only, 2 - mdix only");
 
 struct e1000_option {
 	enum { enable_option, range_option, list_option } type;
@@ -247,6 +256,24 @@ void __devinit e1000e_check_options(struct e1000_adapter *adapter)
 		e_notice("Using defaults for all values\n");
 	}
 
+	{ /* MDI/MDI-X crossover control */
+		const struct e1000_option opt = {
+			.type = range_option,
+			.name = "MDI-X crossover control",
+			.err  = "using default of automatic",
+			.def  = AUTO_ALL_MODES,
+			.arg  = { .r = { .min = AUTO_ALL_MODES,
+					 .max = FORCE_MDIX } }
+		};
+
+		if (num_mdix > bd) {
+			unsigned int mdix_setting = mdix[bd];
+			e1000_validate_option(&mdix_setting, &opt, adapter);
+			hw->phy.mdix = (u8)mdix_setting;
+		} else {
+			hw->phy.mdix = opt.def;
+		}
+	}
 	{ /* Transmit Interrupt Delay */
 		const struct e1000_option opt = {
 			.type = range_option,
